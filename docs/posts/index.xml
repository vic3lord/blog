<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Posts on Or Elimelech</title>
    <link>https://or-e.net/posts/</link>
    <description>Recent content in Posts on Or Elimelech</description>
    <image>
      <url>https://or-e.net/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://or-e.net/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 08 May 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://or-e.net/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Add Protobuf messages into gRPC errors.</title>
      <link>https://or-e.net/posts/grpc-details/</link>
      <pubDate>Sun, 08 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://or-e.net/posts/grpc-details/</guid>
      <description>I had encountred a number of times for the need to give a structured message through gRPC errors The default Go err or status.Errorf functions are simple strings by default.
func (s *Server) LintFile(ctx context.Context, req *LintRequest) (*LintResponse, error) { lintRes, err := lint(ctx, req.GetFile()) if err != nil { return nil, status.New(codes.FailedPrecondition, &amp;#34;File isn&amp;#39;t valid&amp;#34;).WithDetails(lintRes) } return &amp;amp;LintResponse{}, nil } The example above illustrates a situation where you need to know what exactly was wrong with the file, The line number of where the error happened, what&amp;rsquo;s the reason etc.</description>
    </item>
    
    <item>
      <title>Build a datalake on top of BigQuery</title>
      <link>https://or-e.net/posts/bigquery-lakehouse/</link>
      <pubDate>Mon, 14 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://or-e.net/posts/bigquery-lakehouse/</guid>
      <description>Google BigQuery is a very powerful, serverless data warehosue that lets you ingest unlimited data on a pay-per-use basis (storage + querying). The primary advantage of data warehouses is the ability to quickly query and analyze immense amounts of structured data.
Modern data warehouses support new, unstructured data types such as JSON, Avro, and so on, which makes these data warehouses a great contender for data lakes. BigQuery recently added native JSON column type, which we can leverage for our semi-structured lakehouse.</description>
    </item>
    
  </channel>
</rss>
